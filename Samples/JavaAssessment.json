{
    "title": "Java Assessment",
    "desc": "This assessment determines a candidates level of Java skills for an interview.",
    "iconImage": "http://f.cl.ly/items/3v3q1d1P210n2c290e0C/dragonIcon.png",
    "wallImage": "http://f.cl.ly/items/1F2E0A0H1D2U0z1V3Q2s/Wallpaper.png",
    "chapters": [
        {
            "title": "Basics: The Java Language",
            "desc": "A mix of multiple choice and essay like answers of varying difficulty covering the basics of the Java Language.",
            "lessons": [
                {
                    "title": "Introduction Video",
                    "desc": "Introduction to the testing",
                    "type": "video",
                    "video": "oKiYuIsPxYk",
                    "videoType": "youtube"
                },
                {
                    "title": "Language basics",
                    "type": "essay",
                    "questions": [{
                        "question": "What is the difference between an Interface and an Abstract class?",
                        "answers": [{
                                "answer": "<u>An abstract class can have instance methods that implement a default behavior.</b> An Interface can only declare constants and instance methods, but cannot implement default behavior and all methods are implicitly abstract.", 
                                "points": 1
                            },
                            {
                                "answer": "<u>An interface has only public members and no implementation.</b> An abstract class is a class which may have the usual flavors of class members (private, protected, etc.), but has some abstract methods.",
                                "points": 1
                            }]
                        },
                        {
                        "question": "What is the purpose of garbage collection in Java, and when is it used?",
                        "answers": [{
                                "answer": "The purpose of garbage collection is to <u>identify and discard objects that are no longer needed</u> by a program so that their resources can be reclaimed and reused.", 
                                "points": 1
                            },
                            {
                                "answer": "A Java object is subject to garbage collection <u>when it becomes unreachable</u> to the program in which it is used.",
                                "points": 1
                            }]
                        },
                                                {
                        "question": "What are pass-by-reference and pass-by-value?",
                        "answers": [{
                                "answer": "Pass-By-Reference means the <u>passing the address</u> of an object rather than passing the value.", 
                                "points": 1
                            },
                            {
                                "answer": "Pass-by-Value means <u>passing a copy of the value</u> to be passed.",
                                "points": 1
                            }]
                        },                      
                        {
                        "question": "What is the difference between HashMap and Map?",
                        "answers": [{
                                "answer": "<u>Map is Interface</u> ", 
                                "points": 1
                            },
                            {
                                "answer": "and <u>Hashmap is class that implements</u> that.",
                                "points": 1
                            }]
                        },                      
                        {
                        "question": "What is the difference between HashMap and HashTable?",
                        "answers": [{
                                "answer": "<u>HashMap allows null values as key and value</u> whereas Hashtable doesnt allow.  ",
                                "points": 1
                            },
                            {
                                "answer": "<u>HashMap does not guarantee that the order</u> of the map will remain constant over time.",
                                "points": 1
                            },
                            {
                                "answer": "<u>HashMap is unsynchronized</u> and Hashtable is synchronized.",
                                "points": 1
                            }]
                        },                      
                        {
                        "question": "What is the difference between Vector and ArrayList?",
                        "answers": [{
                                "answer": "<u>Vector is synchronized whereas ArrayList is not</u>.", 
                                "points": 1
                            }]
                        },                      
                        {
                        "question": "What is the difference between Swing and Awt?",
                        "answers": [{
                                "answer": "AWT are heavy-weight componenets. <u>Swing are light-weight components</u>. ", 
                                "points": 1
                            },
                            {
                                "answer": "Hence <u>Swing works faster than AWT.</u>",
                                "points": 1
                            }]
                        },                      
                        {
                        "question": "What is the difference between a constructor and a method?",
                        "answers": [{
                                "answer": "A constructor is a member <u>function of a class that is used to create objects of that class</u>. ", 
                                "points": 1
                            },
                            {
                                "answer": "<u>A constructor has the same name as the class itself</u>, ",
                                "points": 1
                            },
                            {
                                "answer": "and has <u>no return type</u>, ",
                                "points": 1
                            },
                            {
                                "answer": "and is <u>invoked using the new operator.</u> ",
                                "points": 1
                            },
                            {
                                "answer": "A method is an ordinary member function of a class. <u>It has its own name, a return type (which may be void), and is invoked using the dot operator.</u>",
                                "points": 1
                            }]
                        },                      
                        {
                        "question": "What is an Iterator?",
                        "answers": [{
                                "answer": "Some of the collection classes provide <u>traversal of their contents via a java.util.Iterator</u> interface. ", 
                                "points": 1
                            },
                            {
                                "answer": "This interface <u>allows you to walk through a collection of objects, operating on each object in turn.</u> ",
                                "points": 1
                            },
                            {
                                "answer": "Iterators that they <u>contain a snapshot of the collection at the time the Iterator was obtained</u>; generally it is not advisable to modify the collection itself while traversing an Iterator.",
                                "points": 2
                            }]
                        },                      
                        {
                        "question": "State the significance of public, private, protected, default modifiers both singly and in combination and state the effect of package relationships on declared items qualified by these modifiers.",
                        "answers": [{
                                "answer": "public : Public class is <u>visible in other packages</u>, field is visible everywhere (class must be public too)", 
                                "points": 1
                            },
                            {
                                "answer": "private : Private variables or methods may be used only by an instance of the same class that declares the variable or method, A <u>private feature may only be accessed by the class that owns the feature</u>.",
                                "points": 1
                            },
                            {
                                "answer": "protected : Is available to all classes in the same package and also available to all subclasses of the class that owns the protected feature. <u>This access is provided even to subclasses that reside in a different package from the class that owns the protected feature.</u>.",
                                "points": 1
                            },
                            {
                                "answer": "default :What you get by default ie, without any access modifier (ie, public private or protected). <u>It means that it is visible to all within a particular package.</u>.",
                                "points": 1
                            }]
                        },                      
                        {
                        "question": "What is an abstract class?",
                        "answers": [{
                                "answer": "<u>Abstract class must be extended/subclassed (to be useful)</u>. It serves as a template. A class that is abstract may not be instantiated (ie, you may not call its constructor), abstract class may contain static data. Any class with an abstract method is automatically abstract itself, and must be declared as such.", 
                                "points": 1
                            },
                            {
                                "answer": "<u>A class may be declared abstract even if it has no abstract methods. This prevents it from being instantiated.</u>",
                                "points": 1
                            }]
                        },                      
                        {
                        "question": "What is static in Java?",
                        "answers": [{
                                "answer": "<u>Static means one per class, not one for each object no matter how many instance of a class might exist</u>. This means that you can use them without creating an instance of a class.Static methods are implicitly final, because overriding is done based on the type of the object, and static methods are attached to a class, not an object. A static method in a superclass can be shadowed by another static method in a subclass, as long as the original method was not declared final. However, you can’t override a static method with a nonstatic method. In other words, you can’t change a static method into an instance method in a subclass.", 
                                "points": 1
                            }]
                        },                      
                        {
                        "question": "What is final?",
                        "answers": [{
                                "answer": "<u>A final class can’t be extended ie., final class may not be subclassed</u>. A final method can’t be overridden when its class is inherited. You can’t change value of a final variable (is a constant).", 
                                "points": 1
                            }]
                        },                      
                        {
                        "question": "What happens if the main method is declared as private?",
                        "answers": [{
                                "answer": "<u>The program compiles properly but at runtime it will give 'Main method not public.' message.</u>", 
                                "points": 1
                            }]
                        },                      
                        {
                        "question": "What if the static modifier is removed from the signature of the main method?",
                        "answers": [{
                                "answer": "<u>Program compiles. But at runtime throws an error 'NoSuchMethodError'.</u>", 
                                "points": 1
                            }]
                        },                      
                        {
                        "question": "What if I write static public void instead of public static void?",
                        "answers": [{
                                "answer": "<u>Program compiles and runs properly.</u>", 
                                "points": 1
                            }]
                        },                      
                        {
                        "question": "What if I do not provide the String array as the argument to the method?",
                        "answers": [{
                                "answer": "<u>Program compiles but throws a runtime error 'NoSuchMethodError'.</u>", 
                                "points": 1
                            }]
                        },                      
                        {
                        "question": "What is the first argument of the String array in main method? How is this different from C/C++",
                        "answers": [{
                                "answer": "<u>The String array is empty. It does not have any element.</u> ", 
                                "points": 1
                            },
                            {
                                "answer": "<u>This is unlike C/C++ where the first element by default is the program name.</u>",
                                "points": 1
                            }]
                        },                      
                        {
                        "question": "If I do not provide any arguments on the command line, then the String array of Main method will be empty or null?",
                        "answers": [{
                                "answer": "<u>It is empty.</u> ", 
                                "points": 1
                            },
                            {
                                "answer": "<u>But not null.</u>",
                                "points": 1
                            }]
                        },                      
                        {
                        "question": "How can one prove that the array is not null but empty using one line of code?",
                        "answers": [{
                                "answer": "Print args.length. It will print 0. That means it is empty.", 
                                "points": 1
                            },
                            {
                                "answer": "But if it would have been null then it would have thrown a NullPointerException on attempting to print args.length.",
                                "points": 1
                            }]
                        },                      
                        {
                        "question": "What environment variables do I need to set on my machine in order to be able to run Java programs?",
                        "answers": [{
                                "answer": "<u>CLASSPATH</u> ", 
                                "points": 1
                            },
                            {
                                "answer": "and <u>PATH</u> are the two variables.",
                                "points": 1
                            }]
                        },                      
                        {
                        "question": "Can an application have multiple classes having main method? Explain.",
                        "answers": [{
                                "answer": "<u>Yes it is possible.</u> ", 
                                "points": 1
                            },
                            {
                                "answer": "<u>While starting the application we mention the class name to be run.</u> The JVM will look for the Main method only in the class whose name you have mentioned. Hence there is not conflict amongst the multiple classes having main method.",
                                "points": 1
                            }]
                        },                      
                        {
                        "question": "Can I have multiple main methods in the same class?",
                        "answers": [{
                                "answer": "<u>No,</u> the program fails to compile. The compiler says that the main method is already defined in the class.", 
                                "points": 1
                            }]
                        },
                        {
                        "question": "Do I need to import java.lang package any time? Why?",
                        "answers": [{
                                "answer": "<u>No.</u> ", 
                                "points": 1
                            },
                            {
                                "answer": "<u>It is by default loaded internally by the JVM.</u>",
                                "points": 1
                            }]
                        },                      
                        {
                        "question": "Can I import same package/class twice? Will the JVM load the package twice at runtime?",
                        "answers": [{
                                "answer": "<u>Yes </u>, One can import the same package or same class multiple times. Neither compiler nor JVM complains about it. ", 
                                "points": 1
                            },
                            {
                                "answer": "And the <u>JVM will internally load the class only once</u> no matter how many times you import the same class.",
                                "points": 1
                            }]
                        },
                        {
                        "question": "What are Checked and UnChecked Exception? Explain the difference.",
                        "answers": [{
                                "answer": "<u>A checked exception is some subclass of Exception (or Exception itself)</u>, excluding class RuntimeException and its subclasses.", 
                                "points": 1
                            },
                            {
                                "answer": "<u>Unchecked exceptions are RuntimeException and any of its subclasses</u>. Class Error and its subclasses also are unchecked. With an unchecked exception, however, the compiler doesn’t force client programmers either to catch the exception or declare it in a throws clause. In fact, client programmers may not even know that the exception could be thrown. eg, StringIndexOutOfBoundsException thrown by String’s charAt() method·",
                                "points": 1
                            },
                            {
                                "answer": " <u>Checked exceptions must be caught at compile time.</u> Runtime exceptions do not need to be. Errors often cannot be.",
                                "points": 1
                            }]
                        },
                        {
                        "question": "What is Overriding? How is it used?",
                        "answers": [{
                                "answer": "<u>When a class defines a method using the same name, return type, and arguments as a method in its superclass, the method in the class overrides the method in the superclass.</u>", 
                                "points": 1
                            },
                            {
                                "answer": "<u>When the method is invoked for an object of the class, it is the new definition of the method that is called, and not the method definition from superclass.</u> Methods may be overridden to be more public, not more private.",
                                "points": 1
                            }]
                        },
                        {
                        "question": "What are the different types of inner classes?",
                        "answers": [{
                                "answer": "<u>Nested top-level classes</u>- If you declare a class within a class and specify the static modifier, the compiler treats the class just like any other top-level class. Any class outside the declaring class accesses the nested class with the declaring class name acting similarly to a package. eg, outer.inner. Top-level inner classes implicitly have access only to static variables.There can also be inner interfaces. All of these are of the nested top-level variety. ", 
                                "points": 1
                            },
                            {
                                "answer": "<u>Member classes</u> – Member inner classes are just like other member methods and member variables and access to the member class is restricted, just like methods and variables. This means a public member class acts similarly to a nested top-level class. The primary difference between member classes and nested top-level classes is that member classes have access to the specific instance of the enclosing class.",
                                "points": 1
                            },
                            {
                                "answer": "<u>Local classes</u> – Local classes are like local variables, specific to a block of code. Their visibility is only within the block of their declaration. In order for the class to be useful beyond the declaration block, it would need to implement a more publicly available interface.Because local classes are not members, the modifiers public, protected, private, and static are not usable. ",
                                "points": 1
                            },
                            {
                                "answer": "<u>Anonymous classes</u> – Anonymous inner classes extend local inner classes one level further. As anonymous classes have no name, you cannot provide a constructor.",
                                "points": 1
                            }]
                        },
                        {
                        "question": "Are the imports checked for validity at compile time? e.g. will the code containing an import such as java.lang.ABCD compile?",
                        "answers": [{
                                "answer": "<u>Yes</u> the imports are checked for the semantic validity at compile time. ", 
                                "points": 1
                            },
                            {
                                "answer": "The code containing above line of import will not compile. It will throw an <u>error saying, can not resolve symbol</u> symbol : class ABCD location: package lang import java.lang.ABCD",
                                "points": 1
                            }]
                        },
                        {
                        "question": "Does importing a package imports the subpackages as well? e.g. Does importing com.MyTest.* also import com.MyTest.UnitTests.*?",
                        "answers": [{
                                "answer": "<u>No</u> you will have to import the subpackages explicitly. Importing com.MyTest.* will import classes in the package MyTest only. It will not import any class in any of it’s subpackage.", 
                                "points": 1
                            }]
                        },
                        {
                        "question": "What is the difference between declaring a variable and defining a variable?",
                        "answers": [{
                                "answer": "<u>In declaration we do not initialize it</u>. We just mention the type of the variable and it’s name. But defining means declaration + initialization.", 
                                "points": 1
                            }]
                        },
                        {
                        "question": "What is the default value of an object reference declared as an instance variable?",
                        "answers": [{
                                "answer": "<u>null</u> ", 
                                "points": 1
                            },
                            {
                                "answer": "<u>unless we define it explicitly.</u>",
                                "points": 1
                            }]
                        },
                        {
                        "question": "Can a top level class be private or protected?",
                        "answers": [{
                                "answer": "<u>No.</u> A top level class can not be private or protected. ", 
                                "points": 1
                            },
                            {
                                "answer": "<u>It can have either “public” or no modifier.</u> If it does not have a modifier it is supposed to have a default access.If a top level class is declared as private the compiler will complain that the “modifier private is not allowed here”. This means that a top level class can not be private. Same is the case with protected.",
                                "points": 1
                            }]
                        },
                        {
                        "question": "What type of parameter passing does Java support? Pass-by-Value or Pass-By-Reference",
                        "answers": [{
                                "answer": "Arguments are always <u>Pass-by-Value</u>", 
                                "points": 1
                            }]
                        },
                        {
                        "question": "Primitive data types are passed by reference or pass by value?",
                        "answers": [{
                                "answer": "Primitive data types are <u>passed by value.</u>", 
                                "points": 1
                            }]
                        },
                        {
                        "question": "Objects are passed by value or by reference?",
                        "answers": [{
                                "answer": "Java only supports <u>pass by value.</u> ", 
                                "points": 1
                            },
                            {
                                "answer": "With objects, <u>the object reference itself is passed by value</u> and so both the original reference and parameter copy both refer to the same object .",
                                "points": 1
                            }]
                        },
                        {
                        "question": "Does Java provide any construct to find out the size of an object?",
                        "answers": [{
                                "answer": "<u>No there is not sizeof operator in Java.</u> So there is not direct way to determine the size of an object directly in Java.", 
                                "points": 1
                            }]
                        },
                        {
                        "question": "Give a simplest way to find out the time a method takes for execution without using any profiling tool?",
                        "answers": [{
                                "answer": "<u>Read the system time just before the method is invoked and immediately after method returns.</u> Take the time difference, which will give you the time taken by a method for execution.\n ", 
                                "points": 1
                            },
                            {
                                "answer": "<u>To put it in code… \nlong start = System.currentTimeMillis ();\nmethod ();\nlong end = System.currentTimeMillis ();\nSystem.out.println (“Time taken is ” + (end – start));</u>",
                                "points": 2
                            }]
                        },
                        {
                        "question": "How are Observer and Observable used?",
                        "answers": [{
                                "answer": "<u>Objects that subclass the Observable class maintain a list of observers.</u> ", 
                                "points": 2
                            },
                            {
                                "answer": "<u>When an Observable object is updated it invokes the update() method of each of its observers to notify the observers that it has changed state.</u> ",
                                "points": 1
                            }
                            ,
                            {
                                "answer": "<u>The Observer interface is implemented by objects that observe Observable objects.</u>",
                                "points": 1
                            }]
                        },
                        {
                        "question": "How does Java handle integer overflows and underflows?",
                        "answers": [{
                                "answer": "<u>It uses those low order bytes of the result that can fit into the size of the type allowed by the operation.</u>", 
                                "points": 3
                            }]
                        },
                        {
                        "question": "Does garbage collection guarantee that a program will not run out of memory?",
                        "answers": [{
                                "answer": "<u>No, Garbage collection does not guarantee that a program will not run out of memory.</u> ", 
                                "points": 1
                            },
                            {
                                "answer": "It is possible for programs to <u>use up memory resources faster than they are garbage collected.</u> ",
                                "points": 1
                            }
                            ,
                            {
                                "answer": "It is also possible for programs to <u>create objects that are not subject to garbage collection.</u>",
                                "points": 1
                            }]
                        },
                        {
                        "question": "What are the steps and code in setting up a JDBC connection?",
                        "answers": [{
                                "answer": "1 : <u>Register the database driver by using : class.forName(\"driver class for that specific database\" );</u>\n", 
                                "points": 1
                            },
                            {
                                "answer": "2 : Now <u>create a database connection</u> using : Connection con = DriverManager.getConnection(url,username,password);\n",
                                "points": 1
                            },
                            {
                                "answer": "3: Now <u>Create a query using : Statement stmt = Connection.Statement(\"select * from TABLE NAME\");</u>\n",
                                "points": 1
                            },
                            {
                                "answer": "4 : <u>Execute the query : stmt.exceuteUpdate();</u>",
                                "points": 1
                            }]
                        },
                        {
                        "question": "What is the Locale class?",
                        "answers": [{
                                "answer": "The Locale class is used to <u>tailor program output to the conventions of a particular geographic, political, or cultural region.</u>", 
                                "points": 1
                            }]
                        }
                    ]
                },
                {   "title": "Threading",
                    "desc": "Threading basics",
                    "type": "essay",
                    "questions": [{
                        "question": "Describe synchronization in respect to multithreading.",
                        "answers": [{
                                "answer": "With respect to multithreading, synchronization is the <u>capability to control the access of multiple threads to shared resources.</u> ", 
                                "points": 1
                            },
                            {
                                "answer": "<u>Without synchonization, it is possible for one thread to modify a shared variable while another thread is in the process of using or updating same shared variable.</u> This usually leads to significant errors.",
                                "points": 1
                            }]
                        },                      
                        {
                        "question": "What are synchronized methods and synchronized statements?",
                        "answers": [{
                                "answer": "Synchronized methods are <u>methods that are used to control access to an object.</u> ", 
                                "points": 1
                            },
                            {
                                "answer": "<u>A thread only executes a synchronized method after it has acquired the lock for the method’s object or class.</u> ",
                                "points": 1
                            },
                            {
                                "answer": "Synchronized statements are similar to synchronized methods. A synchronized statement can only be <u>executed after a thread has acquired the lock for the object or class referenced in the synchronized statement.</u>",
                                "points": 2
                            }]
                        },
                        {
                        "question": "What is daemon thread and which method is used to create the daemon thread?",
                        "answers": [{
                                "answer": "Daemon thread is <u>a low priority thread which runs intermittently in the back ground doing the garbage collection operation for the java runtime system.</u> ", 
                                "points": 1
                            },
                            {
                                "answer": "<u>setDaemon method is used to create a daemon thread.</u>",
                                "points": 1
                            }]
                        },
                        {
                        "question": "Explain different way of using thread? And the difference.",
                        "answers": [{
                                "answer": "The thread could be implemented by using <u>runnable interface</u> ", 
                                "points": 1
                            },
                            {
                                "answer": "<u> or by inheriting from the Thread class.</u>",
                                "points": 1
                            },
                            {
                                "answer": "Runnable Interface is more advantageous, because when you are going for multiple inheritance..the only interface can help.</u>",
                                "points": 2
                            }]
                        },                      
                        {
                        "question": "What is synchronization and why is it important?",
                        "answers": [{
                                "answer": "With respect to multithreading, <u>synchronization is the capability to control the access of multiple threads to shared resources.</u> ", 
                                "points": 1
                            },
                            {
                                "answer": "<u>Without synchronization, it is possible for one thread to modify a shared object while another thread is in the process of using or updating that object’s value. This often leads to significant errors.</u>",
                                "points": 2
                            }]
                        },
                        {
                        "question": "What is the difference between preemptive scheduling and time slicing?",
                        "answers": [{
                                "answer": "Under <u>preemptive scheduling, the highest priority task executes until it enters the waiting or dead states or a higher priority task comes into existence.</u> ", 
                                "points": 2
                            },
                            {
                                "answer": "Under <u>time slicing, a task executes for a predefined slice of time and then reenters the pool of ready tasks. The scheduler then determines which task should execute next, based on priority and other factors.</u>",
                                "points": 2
                            }]
                        },
                        {
                        "question": "When a thread is created and started, what is its initial state?",
                        "answers": [{
                                "answer": "A: A thread is in the <u>ready state</u> after it has been created and started.", 
                                "points": 2
                            }]
                        },
                    ]
                },
                {   "title": "Serialization",
                    "desc": "Serialization basics",
                    "type": "essay",
                    "questions": [{
                        "question": "What is serialization?",
                        "answers": [{
                                "answer": "<u>Serialization is a mechanism by which you can save the state of an object by converting it to a byte stream.</u>", 
                                "points": 1
                            }]
                        },
                        {
                        "question": "How do I serialize an object to a file?",
                        "answers": [{
                                "answer": "The class whose instances are to be serialized should <u>implement an interface Serializable</u>. ", 
                                "points": 1
                            },
                            {
                                "answer": "Then you <u>pass the instance to the ObjectOutputStream which is connected to a fileoutputstream</u>. This will save the object to a file.",
                                "points": 1
                            }]
                        },
                        {
                        "question": "Which methods of Serializable interface should I implement?",
                        "answers": [{
                                "answer": "The serializable interface is an empty interface, it does not contain any methods. So <u>we do not implement any methods.</u>", 
                                "points": 1
                            }]
                        },
                        {
                        "question": "Is it possible to customize the seralization process? If it was possible - How would you have control over the serialization process?",
                        "answers": [{
                                "answer": "<u>Yes</u> it is possible to have control over serialization process. ", 
                                "points": 1
                            },
                            {
                                "answer": "<u>The class should implement the Externalizable interface.</u> ",
                                "points": 2
                            },
                            {
                                "answer": "This interface contains <u>two methods namely readExternal and writeExternal</u>. You should implement these methods and write the logic for customizing the serialization process.", 
                                "points": 2
                            }]
                        },
                        {
                        "question": "What is the common usages of serialization?",
                        "answers": [{
                                "answer": "Whenever an object is <u>to be sent over the network, objects need to be serialized.</u> ", 
                                "points": 1
                            },
                            {
                                "answer": "Moreover if the state of <u>an object is to be saved</u>, objects need to be serialized.",
                                "points": 1
                            }]
                        },
                        {
                        "question": "What is Externalizable interface?",
                        "answers": [{
                                "answer": "Thus if your class implements this interface, <u>you can customize the serialization process by implementing its methods.</u> ", 
                                "points": 1
                            },
                            {
                                "answer": "Externalizable is an interface which contains <u>two methods readExternal and writeExternal. These methods give you a control over the serialization mechanism</u>.",
                                "points": 1
                            }]
                        },
                        {
                        "question": "When you serialize an object, what happens to the object references included in the object?",
                        "answers": [{
                                "answer": "<u>The serialization mechanism generates an object graph for serialization</u>. Thus it determines whether the included object references are serializable or not. ", 
                                "points": 1
                            },
                            {
                                "answer": "This is a <u>recursive process</u>. ",
                                "points": 1
                            }
                            ,
                            {
                                "answer": "Thus when an object is serialized, <u>all the included objects are also serialized along with the original object.</u>",
                                "points": 1
                            }]
                        },
                        {
                        "question": "What one should take care of while serializing the object?",
                        "answers": [{
                                "answer": "One should <u>make sure that all the included objects are also serializable.</u> ", 
                                "points": 2
                            },
                            {
                                "answer": "<u>If any of the objects is not serializable then it throws a NotSerializableException.</u>",
                                "points": 1
                            }]
                        },
                        {
                        "question": "What happens to the static fields of a class during serialization?",
                        "answers": [{
                                "answer": "A: There are <u>three exceptions in which serialization does not necessarily read and write to the stream.</u> These are", 
                                "points": 1
                            },
                            {
                                "answer": "1. Serialization <u>ignores static fields</u>, because they are not part of a particular state state.\n ",
                                "points": 1
                            },
                            {
                                "answer": "2. <u>Base class fields are only handled if the base class itself is serializable.</u>\n ",
                                "points": 1
                            },
                            {
                                "answer": "3. <u>Transient fields</u>.",
                                "points": 1
                            }]
                        }
                    ]
                },
                {   "title": "Exception handling and scope",
                    "desc": "Java exception handling and blocks and Scope",
                    "type": "essay",
                    "questions": [{
                        "question": "If I write System.exit (0); at the end of the try block, will the finally block still execute?",
                        "answers": [{
                                "answer": "<u>No in this case the finally block will not execute because when you say System.exit (0); the control immediately goes out of the program, and thus finally never executes.</u>", 
                                "points": 2
                            }]
                        },
                        {
                        "question": "What are wrapper classes?",
                        "answers": [{
                                "answer": "Java provides <u>specialized classes corresponding to each of the primitive data types</u>. These are called wrapper classes. They are e.g. Integer, Character, Double etc.", 
                                "points": 1
                            }]
                        },
                        {
                        "question": "Why do we need wrapper classes?",
                        "answers": [{
                                "answer": "It is sometimes <u>easier to deal with primitives as objects.</u> Moreover most of the collection classes store objects and not primitive data types. And also the wrapper classes provide many utility methods also. Because of these resons we need wrapper classes. And since we create instances of these classes we can store them in any of the collection classes and pass them around as a collection. Also we can pass them around as method parameters where a method expects an object.", 
                                "points": 2
                            }]
                        },                        
                        {
                        "question": "What are checked exceptions?",
                        "answers": [{
                                "answer": "Checked exception are <u>those which the Java compiler forces you to catch.</u> e.g. IOException are checked Exceptions.", 
                                "points": 1
                            }]
                        },
                        {
                        "question": "What are runtime exceptions?",
                        "answers": [{
                                "answer": "Runtime exceptions are those exceptions that are thrown at runtime because of either wrong input data or because of wrong business logic etc. These are <u>not checked by the compiler at compile time.</u>", 
                                "points": 1
                            }]
                        },
                        {
                        "question": "What is the difference between error and an exception?",
                        "answers": [{
                                "answer": "<u>An error is an irrecoverable condition occurring at runtime.</u> Such as OutOfMemory error.  ", 
                                "points": 1
                            },
                            {
                                "answer": "These are JVM errors and <u>you can not repair them at runtime.</u> While exceptions are conditions that occur because of bad input etc. e.g. FileNotFoundException will be thrown if the specified file does not exist. Or a NullPointerException will take place if you try using a null reference. In most of the cases it is possible to recover from an exception (probably by giving user a feedback for entering proper values etc.).",
                                "points": 1
                            }]
                        },
                        {
                        "question": "How to create custom exceptions?",
                        "answers": [{
                                "answer": "Your class should <u>extend class Exception, or some more specific type thereof.</u>", 
                                "points": 1
                            }]
                        },
                        {
                        "question": "If I want an object of my class to be thrown as an exception object, what should I do?",
                        "answers": [{
                                "answer": "The class should <u>extend Exception class.</u> Or you can extend your class from some more precise exception type also.", 
                                "points": 1
                            }]
                        },
                        {
                        "question": "If my class already extends from some other class what should I do if I want an instance of my class to be thrown as an exception object?",
                        "answers": [{
                                "answer": "<u>One can not do anything in this scenario. Because Java does not allow multiple inheritance and does not provide any exception interface as well.</u>", 
                                "points": 2
                            }]
                        },
                        {
                        "question": "How does an unhandled exception permeate through the code?",
                        "answers": [{
                                "answer": "An unhandled exception <u>moves up the method stack</u> ", 
                                "points": 1
                            },
                            {
                                "answer": "in search of a matching When an exception is thrown from a code which is wrapped in a try block followed by one or more catch blocks, a search is made for matching catch block. If a matching type is found then that block will be invoked. If a matching type is not found then the exception moves up the method stack and reaches the caller method. Same procedure is repeated if the caller method is included in a try catch block. This process continues <u>until a catch block handling the appropriate type of exception is found</u>. If it does not find such a block then finally the program terminates.",
                                "points": 2
                            }]
                        },
                        {
                        "question": "What are the different ways to handle exceptions?",
                        "answers": [{
                                "answer": "1. By <u>wrapping the desired code in a try block followed by a catch block to catch the exceptions.</u> And ", 
                                "points": 1
                            },
                            {
                                "answer": "2. <u>List the desired exceptions in the throws clause of the method</u> and let the caller of the method hadle those exceptions.",
                                "points": 1
                            }]
                        },
                        {
                        "question": "If I write return at the end of the try block, will the finally block still execute?",
                        "answers": [{
                                "answer": "<u>Yes</u> even if you write return as the last statement in the try block and no exception occurs, the finally block will execute.", 
                                "points": 1
                            }]
                        },
                        {
                        "question": "What is the purpose of finalization?",
                        "answers": [{
                                "answer": "The purpose of finalization is <u>to give an unreachable object the opportunity to perform any cleanup processing before the object is garbage collected.</u>", 
                                "points": 2
                            }]
                        },
                        {
                        "question": "What is the difference between a while statement and a do statement?",
                        "answers": [{
                                "answer": "A <u>while statement checks at the beginning of a loop to see whether the next loop iteration should occur. A do statement checks at the end of a loop to see whether the next iteration of a loop should occur.</u> ", 
                                "points": 1
                            },
                            {
                                "answer": "The <u>do statement will always execute the body of a loop at least once.</u>",
                                "points": 1
                            }]
                        },
                        {
                        "question": "What is the difference between static and non-static variables?",
                        "answers": [{
                                "answer": "A <u>static variable is associated with the class as a whole rather than with specific instances of a class. Non-static variables take on unique values with each object instance.</u>", 
                                "points": 1
                            }]
                        },
                        {
                        "question": "How are this() and super() used with constructors?",
                        "answers": [{
                                "answer": "<u>this() is used to invoke a constructor of the same class.</u> ", 
                                "points": 1
                            },
                            {
                                "answer": "<u>super() is used to invoke a superclass constructor.</u>",
                                "points": 1
                            }]
                        }                    ]
                }
            ]
        }
    ]
}